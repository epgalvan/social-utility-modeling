Model the Data Generation Process
*********

.. article-info::
    :avatar: dnl_plastic.png
    :avatar-link: https://www.decisionneurosciencelab.com/
    :author: Elijah Galvan
    :date: September 1, 2023
    :read-time: 10 min read
    :class-container: sd-p-2 sd-outline-muted sd-rounded-1

Goals During this Stage
================

We want to mathematically model the data generation process - in other words, develop an equation that predicts what all people will decide in each trial.

.. Warning::

    Mathematically modeling the data generation process is the most difficult step in the computational modeling process: there is no objectively correct way to go about it. 
    With that said, I believe that this is achievable in a timely manner when given the correct goals and a useful framework. 

1. For each motive you have identified, create a function which takes :bdg-danger:`decisions`, :bdg-primary:`independent variables`, and :bdg-primary:`constants` as inputs, 
and outputs a value which reflects the :bdg-secondary:`construct value` of such a motive based on :bdg-danger-line:`decisions`.

.. dropdown:: Conceptual Examples of :bdg-secondary:`construct value` Formulations

    Here the :bdg-danger-line:`decision` (the chosen option) is represented as Decision, the option which most closely follows the norm is represented as Norm, and the option which most strongly violates the norm is represented as Maximum Norm Violation. 

    .. Note::

        All differences are set to the absolute value. 
        The logic of this choice is that the direction of the norm violation is not important: violating a norm in either direction results in disutility. 
        If norm violation in one direction could result in a positive utility, this should not be done. 
        However, in most cases this is appropriate (albiet unnecessary from a design perspective since usually such deviations are not possible).

    :bdg-secondary:`Raw Norm Violation` = (|Norm - Decision|)/(Maximum Norm Violation)

    * If any violation of the norm results in disutility

    :bdg-secondary:`Unidirectional Norm Violation` = (|max((Norm - Decision), 0)|)/(Maximum Norm Violation)

    * If the Norm is violated in one direction but not another 
    * Could also use min
    * The second argument (0 here) can be anything, though 0 is usually the most meaningful

    :bdg-secondary:`Normalized Norm Violation` = ((|Norm - Decision|)/(|Maximum Norm Violation - Norm|))

    * If all choices result in a norm being violated to some extent, disutility is not experienced by choosing the closest value to the norm

    :bdg-secondary:`Squared Normalized Norm Violation` = ((Norm - Decision)/(Maximum Norm Violation - Norm))²

    * If smaller norm violations are less significant than a linear relationship would suggest

    :bdg-secondary:`Square Root Normalized Norm Violation` = sqrt((Norm - Decision)/(Maximum Norm Violation - Norm))

    * If smaller norm violations are more significant than a linear relationship would suggest

    .. Note::

       Adherance = 1 - Violation



If you plot the output (let's call this our :bdg-secondary:`construct values` ) against :bdg-danger-line:`decisions` for a few trials (with a few example combinations of :bdg-primary:`independent variables` ) and it makes sense to you, then great job! 
Otherwise, think about how you can fix it so that it will make sense. 

2. Identify which :bdg-success:`free parameters` are relevant for each :bdg-secondary:`construct value` in determining :bdg-warning:`Utility`

3. Identify how each :bdg-secondary:`construct value` mathematically interacts with the relevant :bdg-success:`free parameters` to determine :bdg-warning:`Utility`.

.. dropdown:: General :bdg-warning:`Utility` Equation Formulation

    :bdg-warning:`Utility` =   

        (:bdg-secondary:`Utility Source 1` × :bdg-success:`Relevant Free Parameters`) + ... + 

        (:bdg-secondary:`Utility Source N` × :bdg-success:`Relevant Free Parameters`)

.. dropdown:: Examples of :bdg-warning:`Utility` Equations

    .. Note:: 
        SN is shorthand for Social Norm - when there are multiple social norms we use numbers to demarcate.
        
        Adh is shorthand for Adherance. 
        Vio is shorthand for Violation. 

    1 Parameter

    .. dropdown:: :bdg-warning:`Utility` =  :bdg-secondary:`Payout Adh` × :bdg-success:`Θ`  - (1 - :bdg-success:`Θ` ) × :bdg-secondary:`SN Vio` 

        :bdg-success:`Θ` = [0, 1]

        :bdg-secondary:`Payout Adh` = `Normalized Norm Adherance` = [0, 1]

        :bdg-secondary:`SN1 Vio` = `Squared Normalized Norm Violation` = [0, 0.25]

    2 Parameter 

    .. dropdown:: :bdg-warning:`Utility` =  :bdg-secondary:`Payout Adh` × :bdg-success:`Θ`  + (1 - :bdg-success:`Θ` ) × ( :bdg-success:`Φ` × :bdg-secondary:`SN1 Adh` + (1 - :bdg-success:`Φ` ) × :bdg-secondary:`SN2 Adh` )

        :bdg-success:`Θ` = [0, 1]

        :bdg-success:`Φ` = [0, 1]

        :bdg-secondary:`Payout Adh` = `Squared Normalized Norm Adherance` = [0, 1]

        :bdg-secondary:`SN1 Adh` = `Squared Normalized Norm Adherance` = [0, 1]

        :bdg-secondary:`SN2 Adh` = `Squared Normalized Norm Adherance` = [0, 1]

        .. Note:: 

            This model was used in multiplayer choice. 
            Thus, SN1 Adh and SN2 Adh were computed as ``1 - (sum(Norm Violation for Each Player²)/sum(Maximum Norm Violation for Each Player²))``.

    .. dropdown:: :bdg-warning:`Utility` = :bdg-secondary:`Payout Adh` × :bdg-success:`Θ`  - (1 - :bdg-success:`Θ` ) × ( :bdg-success:`Φ` × :bdg-secondary:`SN1 Vio` + (1 - :bdg-success:`Φ` ) × :bdg-secondary:`SN2 Vio` )

        :bdg-success:`Θ` = [0, 0.5]

        :bdg-success:`Φ` = [0, 1]
        
        :bdg-secondary:`Payout Adh` = `Normalized Norm Adherance` = [0, 1]

        :bdg-secondary:`SN1 Vio` = `Squared Normalized Norm Violation` = [0, 0.25]

        :bdg-secondary:`SN2 Vio` = `Squared Normalized Norm Violation` = [0, 0.25]

    .. dropdown:: :bdg-warning:`Utility` = :bdg-secondary:`Payout Adh` × :bdg-success:`Θ`  - (1 - :bdg-success:`Θ` ) × min( :bdg-secondary:`SN1 Vio` +  :bdg-success:`Φ` , :bdg-secondary:`SN2 Vio` -  :bdg-success:`Φ` )

        :bdg-success:`Θ` = [0, 0.5]

        :bdg-success:`Φ` = [-0.1, 0.1]
        
        :bdg-secondary:`Payout Adh` = `Normalized Norm Adherance` = [0, 1]

        :bdg-secondary:`SN1 Vio` = `Squared Normalized Norm Violation` = [0, 0.25]

        :bdg-secondary:`SN2 Vio` = `Squared Normalized Norm Violation` = [0, 0.25]

Tutorial
================

.. Note::

    If you want to have practice finding the correct model, leave the dropdowns alone and skip to the next section once you have finished both steps in this section. 

    Otherwise, check the answers in the dropdowns below. 
    Please be aware that no examples are given in the documentation for alternative models.


.. dropdown:: For each motive you have identified, create a function which takes :bdg-danger:`decisions` as an input, where :bdg-primary:`independent variables` and :bdg-primary:`constants` are already defined, and outputs a value which scales with motive as a function of :bdg-danger:`decisions`.

    .. dropdown:: Greed

        .. tab-set::

            .. tab-item:: Plain English

                The extent to which one has behaved greedily can be expressed as the proportion of how much they decided to keep for themselves out of how much they *could* have kept for themselves (i.e the extent to which they maximized their payout). 

                In the Trust Game, the maximum amount that the Trustee can keep for themselves is what they received, namely: :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier`. 
                And, therefore, what they :bdg-danger-line:`Keep` is ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` ) - :bdg-danger-line:`Returned`

                Thus, the extent to which one has maximized their payout is:
                
                :bdg-secondary-line:`Payout Maximization` = :bdg-danger-line:`Keep` / (:bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` )

                Since :bdg-danger-line:`Keep` can range from 0 to :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier`, it ranges from 0 to 1, inclusive.

            .. tab-item:: R

                ::

                    payout_maximization = function(investment, multiplier, returned){
                        return(((investment * multiplier) - returned)/(investment * multiplier))
                    }

            .. tab-item:: MatLab

                ::

                    function value = payout_maximization(investment, multiplier, returned)
                        value = ((investment * multiplier) - returned) / (investment * multiplier);
                    end


            .. tab-item:: Python

                :: 
                    
                    def payout_maximization(investment, multiplier, returned):
                        return ((investment * multiplier) - returned) / (investment * multiplier)

    .. dropdown:: Inequity Aversion

        .. tab-set::

            .. tab-item:: Plain English

                Equity is creating an equal division of money in the game. 
                Thus, the extent to the principle of equity has been violated can be expressed as the difference between perfect equity (the norm) and the actual division. 

                In the Trust Game, the Trustee's payout is what they :bdg-danger-line:`Keep` which is ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` ) - :bdg-danger-line:`Returned` 
                while the Investor's payout is what they did not invest which is ( :bdg-primary-line:`Endowment` - :bdg-primary-line:`Investment`). 
                If the Trustee has half of the money in the game, :bdg-danger-line:`Keep` is half of all of the money in the game - 
                the sum of the multiplied investment ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` ) and what the Investor did not invest ( :bdg-primary-line:`Endowment` - :bdg-primary-line:`Investment`).

                .. Note::

                    There are cases where the Investor does not invest enough for the Trustee to achieve Equity: in the paper they elected for the raw norm violation rather than the normalized norm violation so we'll do the same
                    (although I can confirm that this doesn't affect the results). 
                    They also chose a squared formulation based on previous literature. 

                Thus, the extent to which inequity was created (i.e. one violated the principle of equity) is:

                :bdg-secondary-line:`Inequity` = (0.5 - ( :bdg-danger-line:`Keep`/( :bdg-primary-line:`Endowment` - :bdg-primary-line:`Investment` + :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` )))²

                Since :bdg-danger-line:`Keep` can range from 0 to :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` (when :bdg-primary-line:`Endowment` - :bdg-primary-line:`Investment` = 0), the maximum difference can be 0.5 which when squared is 0.25. 
                Thus, :bdg-secondary-line:`Inequity` can range from 0 to 0.25, inclusive.

            .. tab-item:: R

                ::

                    inequity = function(investment, multiplier, returned, endowment){
                        return(((investment * multiplier - returned)/(investment * multiplier - endowment - investment))**2)
                    }

            .. tab-item:: MatLab

                ::

                    function value = inequity(investment, multiplier, returned, endowment)
                        value = ((investment * multiplier - returned)/(investment * multiplier - endowment - investment))^2;
                    end


            .. tab-item:: Python

                :: 
                    
                    def inequity(investment, multiplier, returned, endowment):
                        return(((investment * multiplier - returned)/(investment * multiplier - endowment - investment))**2)
                
    .. dropdown:: Guilt Aversion

        .. tab-set::

            .. tab-item:: Plain English

                Guilt is experienced by violating expectations: in this case, the norm is to give half of what one receives. 
                Thus, the extent to which one has violated the social norm can be expressed as the difference between the expected return on investment and the actual return on investment. 

                In the experiment, :bdg-primary-line:`Believed Multiplier` was a constant - it was always 4 and let's adopt the assumption (which was supported in the data) that Trustees believed that Investor's expected to received half of the multiplied investment. 
                Thus, the expectation can be expressed as ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2. 

                .. Note::


                    Theoretically, giving more than ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2 is represented as a disutility - theoretically caused by an experience of guilt. 
                    Of course this seems unreasonable but let's play this out further - (( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2) - :bdg-danger-line:`Returned` can actually be equal to :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier`. 
                    This could be very problematic: :bdg-secondary-line:`Guilt` can only range from 0 to 0.25 but :bdg-secondary-line:`Guilt` can range from 0 to 1. 

                    Obviously, this is not a huge problem because the model entirely overlooks the possibility that guilt averse people would give more than half of :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` 
                    or that inequity averse people would give more than half of  :bdg-primary-line:`Investment` × :bdg-primary-line:`Multiplier` which seems reasonable. 
                    But still, let's think of what an alternative formulation would be. 

                    .. dropdown:: What's a reasonable alternative formulation?

                        The answer would be to apply a unidirectional formulation: max(((( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2) - :bdg-danger-line:`Returned` ), 0)

                    .. dropdown:: What's wrong with this alternative formulation?

                        The answer would be that it is nonspecific: any return value greater than or equal to ( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2 results in the exact same disutility (i.e. 0). 
                        Specificity is a highly, highly important feature of these models: you need to ensure than models make distinct predictions as much as is possible. 
                        
                        Remember that there is always often tradeoff between specificty, parsimony, and theoretical correctness. 

                Thus with this representation of the norm, then the extent to which it was violated is:

                :bdg-secondary-line:`Guilt` = (((( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/2) - :bdg-danger-line:`Returned` ) /( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` )/( :bdg-primary-line:`Investment` × :bdg-primary-line:`Believed Multiplier` ))²

            .. tab-item:: R

                ::

                    guilt = function(investment, believed_multiplier, returned){
                        return(((investment * believed_multiplier)/2 - returned)/(investment * believed_multiplier))
                    }

            .. tab-item:: MatLab

                ::

                    function value = guilt(investment, believed_multiplier, returned)
                        value = ((investment * believed_multiplier)/2 - returned) / (investment * believed_multiplier);
                    end


            .. tab-item:: Python

                :: 
                    
                    def guilt(investment, believed_multiplier, returned):
                        return ((investment * believed_multiplier)/2 - returned) / (investment * believed_multiplier)

.. dropdown:: Identify which :bdg-success:`free parameters` are relevant for each :bdg-secondary:`construct value` in determining :bdg-warning:`Utility`

    1. :bdg-secondary-line:`Payout Maximization` - :bdg-success:`D1`  
    2. :bdg-secondary-line:`Equity Achieved` - :bdg-success:`D1` & :bdg-success:`D2` 
    3. :bdg-secondary-line:`Expectation Meeting` - :bdg-success:`D1` & :bdg-success:`D2` 

    .. Note::

        Why do we use (1-:bdg-success:`D1` ) and (1-:bdg-success:`D2` )? 
        
        Each dimension we have created is mathematically arbitrary: the fact that greed is endorsed at high values of :bdg-success:`D1` is a consequence of our choice. 
        It could just as reasonably be that greed is endorsed at low values of :bdg-success:`D1`. 
        
        The dimension we created dichtomize one preference against another: thus, we can simply take the inverse

.. dropdown:: Identify how each :bdg-secondary:`construct value` mathematically interacts with the relevant :bdg-success:`free parameters` to determine :bdg-warning:`Utility`

    :bdg-warning:`Utility` = :bdg-secondary-line:`Payout_Maximization` × :bdg-success:`Θ`  - (1 - :bdg-success:`Θ` ) × min( :bdg-secondary-line:`Guilt` +  :bdg-success:`Φ` , :bdg-secondary-line:`Inequity` -  :bdg-success:`Φ` )
    