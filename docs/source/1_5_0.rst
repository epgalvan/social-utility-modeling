Simulating Data
*********

.. article-info::
    :avatar: dnl_plastic.png
    :avatar-link: https://www.decisionneurosciencelab.com/
    :author: Elijah Galvan
    :date: September 1, 2023
    :read-time: 10 min read
    :class-container: sd-p-2 sd-outline-muted sd-rounded-1

Goals During this Stage
================

Now we want to plug in all of the inputs that we know (experimental variables and free parameters) into the data generation process (the computational model) and see what it outputs.

.. figure:: comp_modeling.gif
    :figwidth: 100%
    :align: center

Seems easy enough right? 

.. Note:: 

    Here, the path taken by MatLab will diverge. 
    In comparison with R - which is designed around long format data frames, MatLab is designed around the Matrix. 
    For beginners with access to MatLab and no particular preference about programming language, I would recommend using MatLab. 
    The idea is aligned with the above illustration: each coordinate has a cell in a structure and the contents of the cell are a structure with various fields. 
    So, in essence, where we are essentially saying that each coordinate represents one hypothetical person this means that each cell represents a hypothetical person: 
    we can open the structure in the cell and look at the fields which tell us something about that hypothetical person - their parameter values (together telling us their coordinates in parameter space) and the decisions that they would make.
    
    I chose to keep Python in long format just like R - Python is less concise than either MatLab or R so, to reduce the amount of code to keep track of, this was preferable. 
    Nonethless, I think it is still possible to easily switch by translating the MatLab code to Python with ChatGPT.

.. dropdown:: Preallocating, Defining Functions, Defining Trial List, and Defining Parameters

    .. tab-set::

        .. tab-item:: Plain English

            Before you start simulating data, you need to check off a pretty simple list: 

                1. Define the Trial List

                * Define the value of all :bdg-primary:`Independant Variables` and all relevant :bdg-primary:`Constants` (and all possible :bdg-danger:`Decisions` if these do not change from trial-to-trial)

                2. Define Your Functions

                * Define the value of all :bdg-secondary:`Construct Value` functions and the :bdg-secondary:`Utility` function

                3. Define Your Parameters

                * Define the range and resolution of each of your :bdg-success:`Free Parameters`

                4. Preallocate Model Output

                * Preallocate the data storage structures for the model-predicted :bdg-danger:`Decisions` for each Trial, for each Coordinate

        .. tab-item:: R

            ::

                trialList = data.frame(IndependentVariable = vector(), Constant = vector())

                # choices = vector()

                construct = function(iv, constant, choice){
                    return(construct_value)
                }

                utility = function(constructs, parameters){
                    return(utility)
                }

                freeParameters = data.frame(parameter1 = vector(), 
                                            parameter2 = vector())

                predictions = data.frame()

        .. tab-item:: MatLab

            ::

                trialList = table([], [], 'VariableNames', {'IndependantVariable', 'Constant'});

                % choice

                function value = construct(iv, constant, choice)
                    value = construct_value;
                end

                function value = utility(constructs, parameters)
                    value = utility;
                end

                parameter1range = [];
                parameter2range = [];

                freeParameters = struct('parameter1', {}, 'parameter2', {}, 'predictions', {});
                for i = 1:numel(parameter1range)
                    for j = 1:numel(parameter2range)
                        freeParameters(i, j).parameter1 = parameter1range(i);
                        freeParameters(i, j).parameter2 = parameter2range(j);
                        freeParameters(i, j).predictions = zeros(size(triaList, 1), 1); 
                    end
                end


        .. tab-item:: Python

            :: 

                import pandas as pd
                import numpy as np

                trialList = pd.DataFrame({
                    'IndependantVariable': [],
                    'Constants': [],
                })

                # choices = []

                def construct(iv, constant, choice):
                    return(construct_value)

                def utility(constructs, parameters):
                    return(utility)

                freeParameters = pd.DataFrame({
                    'parameter1': [],
                    'parameter2': []
                })

                predictions = pd.DataFrame()
    

.. dropdown:: Define the :bdg-success:`Free Parameter` Loop

    .. tab-set::

        .. tab-item:: Plain English

            We're going to start our most superior ``for`` loop which iterates over unique combinations of :bdg-success:`Free Parameters`. 

            Each combination of :bdg-success:`Free Parameters` can be thought of as a hypothetical person. 
            In the context of our model, :bdg-success:`Free Parameters` mathematically represent the conceptual dimensions which characterize **all** of the ways that people can be different in your experimental paradigm. 
            Thus, we are generating predictions about what any given person (i.e. a certain coordinate in our parameter space) *would* do in our experiment *if* it is indeed true that our equation aptly represents the data generation process. 

            .. dropdown:: So what are we starting with in this loop? 
                
                :bdg-success:`Free Parameters` 

            .. dropdown:: And what do we want to finish this loop with?

                :bdg-danger:`Decisions` for all of the :bdg-primary:`Trials` in our set. 

            .. dropdown:: So what do we need to preallocate before this loop starts?

                An output for the predicted :bdg-danger:`Decisions`. We already did this above, nice. 

            .. dropdown:: Then, what do we need to compute within this loop?

                We need to determine what the predicted :bdg-danger:`Decisions` for all of the :bdg-primary:`Trials` in our set are for those :bdg-success:`Free Parameters`
            

        .. tab-item:: R

            ::
                
                for (i in 1:length(freeParameters[,1])){
                    parameter1 = freeParameters[i,1]
                    parameter2 = freeParameters[i,2]
                    
                    #Compute Predictions
                    predictions[i,] = #To Compute
                }


        .. tab-item:: MatLab

            ::

                for i = 1:numel(parameter1range)
                    for j = 1:numel(parameter2range)
                        Parameter1 = freeParameters(i,j).parameter1
                        Parameter2 = freeParameters(i,j).parameter2

                        %Compute Predictions
                        freeParameters(i,j).predictions = %toCompute
                    end
                end


        .. tab-item:: Python

            :: 

                for i in range(len(freeParameters)):
                    Parameter1 = freeParameters[i, 0]
                    Parameter2 = freeParameters[i, 1]

                    # Compute Predictions
                    predictions[i, :] = # To Compute

.. dropdown:: Define the :bdg-primary:`Trial` Loop

    .. tab-set::

        .. tab-item:: Plain English

            Now, we are going to begin answering the Compute Predictions demand placed on us in the :bdg-success:`Free Parameter` Loop. 
            So we're within the Coordinate Loop and thus we have our coordinate values defined - so let's say that theoretically we're adopting the perspective of one hypothetical person. 
            What we want to answer specifically is "What should this hypothetical person do on this particular :bdg-primary:`Trial`?".


            .. dropdown:: So what are we starting with in this loop? 

                We're starting with the :bdg-primary:`Independent Variables`, :bdg-primary:`Constants`, and possible :bdg-danger:`Decisions` at the start of each :bdg-primary:`Trial`. 

                We already have :bdg-success:`Free Parameters` defined in the coordinate loop. 

            .. dropdown:: And what do we want to finish this loop with?

                The predicted :bdg-danger:`Decision` for this :bdg-primary:`Trial`. 

            .. dropdown:: So what do we need to preallocate before this loop starts?

                We need to preallocate a vector for all :bdg-danger:`Decisions` for this coordinate pair. 
                However, we already have a preallocated data structure, so for simplicity sake we'll move that within the :bdg-primary:`Trial` loop - defining the model prediction directly on a trial-by-trial basis rather than a coordinate-by-coordinate basis. 

            .. dropdown:: Then, what do we need to compute within this loop?

                We need to compute the :bdg-secondary:`Utility` for all possible :bdg-danger:`Decisions` in this :bdg-primary:`Trial`. 
                Then, we need to save the :bdg-danger:`Decision` which results in the greatest :bdg-secondary:`Utility`.

        .. tab-item:: R

            ::

                for (i in 1:length(freeParameters[,1])){
                    Parameter1 = freeParameters[i,1]
                    Parameter2 = freeParameters[i,2]
                    
                    #Just Added
                    for (k in 1:length(trialList[,1])){
                        IV = trialList[k, 1]
                        Constant = trialList[k, 2]
                        #Choices = vector() #if not already defined
                        
                        # Compute Utility 
                        
                        predictions[i,k] = # To Compute
                    }
                }

        .. tab-item:: MatLab

            ::
                
                for i = 1:numel(thetaRange)
                    for j = 1:numel(phiRange)
                        Parameter1 = freeParameters(i,j).parameter1
                        Parameter2 = freeParameters(i,j).parameter2

                        %Just Added
                        for k = 1:height(trialList(:,1))
                            IV = trialList{k,1};
                            Constant = trialList{k,2};
                            %Choices = []; %if not already defined

                            % Compute Utility

                            freeParameters(i,j).predictions(k) = %toCompute
                        end
                    end
                end

        .. tab-item:: Python

            ::

                for i in range(len(freeParameters)):
                    Parameter1 = freeParameters[i, 0]
                    Parameter2 = freeParameters[i, 1]
                    
                    #Just Added
                    for k in range(len(trialList)):
                        IV = trialList[k, 0]
                        Constant = trialList[k, 1]                        
                        #Choices = [] #if not already defined

                        # Compute Utility
                        
                        predictions[i, k] = # To Compute


.. dropdown:: Define the :bdg-danger:`Decisions` Loop

        .. tab-set::

            .. tab-item:: Plain English

                    We're going to start our most inferior ``for`` loop which iterates over all possible :bdg-danger:`Decisions`. 

                    Here, we're going to answer the Compute Utility demand placed on us in the :bdg-primary:`Trial` loop.

                    .. dropdown:: So what are we starting with in this loop? 
                        
                        We're starting with one of the possible :bdg-success:`Decisions` at the start of each loop. 

                        We already have :bdg-primary:`Independent Variables`, :bdg-primary:`Constants`, and possible :bdg-danger:`Decisions` defined at the start of the :bdg-primary:`Trial` loop and 

                        :bdg-success:`Free Parameters` defined at the start of the :bdg-success:`Free Parameter` loop. 

                    .. dropdown:: And what do we want to finish this loop with?

                        The :bdg-secondary:`Utility` which would be derived for all :bdg-danger:`Decisions` on this :bdg-primary:`Trial`. 

                    .. dropdown:: So what do we need to preallocate before this loop starts?

                        A vector for :bdg-secondary:`Utility` which has the same length as all possible :bdg-danger:`Decisions`. 
                        
                        Also, let's remember that it's possible that multiple :bdg-danger:`Decisions` will maximize utility. 
                        Therefore, let's make sure that our script doesn't error by potentially outputting multiple :bdg-danger:`Decisions` predictions - we'll randomly select between whichever maximizes utility. 
                        Let's also output a vector which keeps track of the number of :bdg-primary:`Trials` where multiple :bdg-danger:`Decisions` maximize :bdg-secondary:`Utility` (i.e. our model makes non-specific predictions) for each pair of :bdg-success:`Free Parameters`. 
                        A few of :bdg-primary:`Trials` for a few :bdg-success:`Free Parameters` is acceptable, but let's just keep an eye on it. 

                    .. dropdown:: Then, what do we need to compute within this loop?

                        Nothing, this is the smallest loop. We're ready to get our answer.
            
            .. tab-item:: R

                ::

                    non_specific = rep(0, length(freeParameters[,1])) # Just Added This Line
                    
                    for (i in 1:length(freeParameters[,1])){
                        Parameter1 = freeParameters[i,1]
                        Parameter2 = freeParameters[i,2]                    
                        for (k in 1:length(trialList[,1])){
                            IV = trialList[k, 1]
                            Constant = trialList[k, 2]
                            #Choices = vector() #if not already defined
                            
                            # Just Added
                            Utility = vector('numeric', length(Choices))
                            for (n in 1:length(Choices)){
                                Utility[n] = utility(parameter1 = Parameter1,
                                                    parameter2 = Parameter2,
                                                    construct = constructs(IV, Constant, Choices[n]))
                            }
                            correct_choice = which(Utility == max(Utility))
                            if (length(correct_choice) > 1){
                                correct_choice = correct_choice[sample(correct_choice, 1)]
                                non_specific[i] =+ 1
                            }
                            predictions[i,k] = Choices[correct_choice]
                        }
                    }
                    
            .. tab-item:: MatLab

                ::
                
                    freeParameters = struct('theta', {}, 'phi', {}, 'predictions', {}, non_specific, {}); %Just Changed This Line

                    for i = 1:numel(thetaRange)
                        for j = 1:numel(phiRange)
                            Parameter1 = freeParameters(i,j).parameter1
                            Parameter2 = freeParameters(i,j).parameter2

                            %Just Added
                            for k = 1:height(trialList(:,1))
                                IV = trialList{k,1};
                                Constant = trialList{k,2};
                                %Choices = []; %if not already defined

                                % Compute Utility
                                Utility = zeros(size(Choices));
                                for n = 1:height(Choices(:,1))
                                    Utility(n) = utility(parameter1 = Parameter1,
                                                        parameter2 = Parameter2,
                                                        construct = constructs(IV, Constant, Choices[n]))
                                end
                                correct_choice = find(Utility == max(Utility));
                                if numel(correct_choice) > 1
                                    correct_choice = correct_choice(randi(numel(correct_choice)));
                                    non_specific(i) = non_specific(i) + 1;
                                end
                                freeParameters(i,j).predictions(k) = Choices(correct_choice)
                            end
                        end
                    end

                    
            .. tab-item:: Python

                ::

                    non_specific = [0] * len(freeParameters) # Just Added this Line 

                    for i in range(len(freeParameters)):
                        Parameter1 = freeParameters[i, 0]
                        Parameter2 = freeParameters[i, 1]
                        
                        for k in range(len(trialList)):
                            IV = trialList[k, 0]
                            Constant = trialList[k, 1]                        
                            #Choices = [] #if not already defined

                            #Just Added
                            Utility = [0] * len(Choices)
                            for n in range(len(Choices)):
                                Utility[n] = utility(parameter1 = Parameter1,
                                                    parameter2 = Parameter2,
                                                    construct = constructs(IV, Constant, Choices[n]))
                            
                            correct_choice = [idx for idx, val in enumerate(Utility) if val == max(Utility)]
                            if len(correct_choice) > 1:
                                correct_choice = random.sample(correct_choice, 1)
                                non_specific[i] += 1

                            predictions[i, k] = Choices[correct_choice[0]]



Tutorial
================

.. dropdown:: Preallocating, Defining Functions, Defining Trial List, and Defining Parameters

        .. tab-set::

            .. tab-item:: R

                ::

                    trialList = data.frame(Investment = rep(seq(1, 10, 1), times = 8),
                                           Multiplier = rep(c(2, 4, 4, 6), each = 20),
                                           Believed_Multiplier = rep(4, 80),
                                           Endowment = rep(10, 80))

                    payout_maximization = function(investment, multiplier, returned){
                        return(((investment * multiplier) - returned)/(investment * multiplier))
                    }

                    inequity = function(investment, multiplier, returned, endowment){
                        return(((investment * multiplier - returned)/(investment * multiplier - endowment - investment))**2)
                    }

                    guilt = function(investment, believed_multiplier, returned){
                        return(((investment * believed_multiplier)/2 - returned)/(investment * believed_multiplier))
                    }

                    utility = function(theta, phi, guilt, inequity, payout){
                        return(theta*payout + (1-theta)*min(guilt + phi, inequity - phi))
                    }

                    freeParameters = data.frame(theta = rep(seq(0, 0.5, 0.005), each = 101), 
                                                phi = rep(seq(-0.1, 0.1, 0.002), times = 101))

                    predictions = data.frame()

            .. tab-item:: MatLab

                ::

                    trialList = table(repelem(1:10, 8)', repmat([2; 4; 4; 6], 20, 1), repmat(4, 80, 1), repmat(10, 80, 1), 'VariableNames', {'Investment', 'Multiplier', 'Believed_Multiplier', 'Endowment'});

                    function value = payout_maximization(investment, multiplier, returned)
                        value = ((investment * multiplier) - returned) / (investment * multiplier);
                    end

                    function value = inequity(investment, multiplier, returned, endowment)
                        value = ((investment * multiplier - returned)/(investment * multiplier - endowment - investment))^2;
                    end

                    function value = guilt(investment, believed_multiplier, returned)
                        value = ((investment * believed_multiplier)/2 - returned) / (investment * believed_multiplier);
                    end

                    function value = utility(theta, phi, guilt, inequity, payout)
                        value = (theta*payout + (1-theta)*min(guilt + phi, inequity - phi));
                    end

                    thetaRange = 0:0.005:0.5;
                    phiRange = -0.1:0.002:0.1;

                    freeParameters = struct('theta', {}, 'phi', {}, 'predictions', {});
                    for i = 1:numel(thetaRange)
                        for j = 1:numel(phiRange)
                            freeParameters(i, j).theta = thetaRange(i);
                            freeParameters(i, j).phi = phiRange(j);
                            freeParameters(i, j).predictions = zeros(80, 1); % Empty vector of length 80
                        end
                    end


            .. tab-item:: Python

                :: 

                    import pandas as pd
                    import numpy as np

                    Investment = np.repeat(np.arange(1, 11), repeats=8)
                    Multiplier = np.repeat([2, 4, 4, 6], repeats=20)
                    Believed_Multiplier = np.repeat(4, 80)
                    Endowment = np.repeat(10, 80)

                    trialList = pd.DataFrame({
                        'Investment': Investment,
                        'Multiplier': Multiplier,
                        'Believed_Multiplier': Believed_Multiplier,
                        'Endowment': Endowment
                    })

                    def payout_maximization(investment, multiplier, returned):
                        return ((investment * multiplier - returned) / (investment * multiplier))
                        
                    def inequity(investment, multiplier, returned, endowment):
                        return ((investment * multiplier - returned) / (investment * multiplier - endowment - investment)) ** 2
                        
                    def guilt(investment, believed_multiplier, returned):
                        return ((investment * believed_multiplier / 2 - returned) / (investment * believed_multiplier))

                    def utility(theta, phi, guilt, inequity, payout){
                        return(theta*payout + (1-theta)*min(guilt + phi, inequity - phi))
                    }
                        
                    theta = np.repeat(np.arange(0, 0.505, 0.005), repeats=101)
                    phi = np.tile(np.arange(-0.1, 0.102, 0.002), 101)

                    freeParameters = pd.DataFrame({
                        'theta': theta,
                        'phi': phi
                    })

                    predictions = pd.DataFrame()

.. dropdown:: Define the Coordinate Loop

    .. tab-set::

        .. tab-item:: R

            ::
                
                for (i in 1:length(freeParameters[,1])){
                    Theta = freeParameters[i,1]
                    Phi = freeParameters[i,2]
                    
                    #Compute Predictions
                    predictions[i,] = #To Compute
                }


        .. tab-item:: MatLab

            ::
                
                for i = 1:numel(thetaRange)
                    for j = 1:numel(phiRange)
                        Theta = freeParameters(i,j).theta
                        Phi = freeParameters(i,j).phi

                        %Compute Predictions
                        freeParameters(i,j).predictions = %toCompute
                    end
                end


        .. tab-item:: Python

            :: 

                for i in range(len(freeParameters)):
                    Theta = freeParameters[i, 0]
                    Phi = freeParameters[i, 1]

                    # Compute Predictions
                    predictions[i, :] = # To Compute

.. dropdown:: Define the Trial Loop

    .. tab-set::

        .. tab-item:: R

            ::

                for (i in 1:length(freeParameters[,1])){
                    Theta = freeParameters[i,1]
                    Phi = freeParameters[i,2]
                    
                    #Just Added
                    for (k in 1:length(trialList[,1])){
                        I = trialList[k, 1]
                        M = trialList[k, 2]
                        B = trialList[k, 3]
                        E = trialList[k, 4]
                        Choices = seq(0, (I * M), 1)
                        
                        # Compute Utility 
                        
                        predictions[i,k] = # To Compute
                    }
                }

        .. tab-item:: MatLab

            ::
                
                for i = 1:numel(thetaRange)
                    for j = 1:numel(phiRange)
                        Theta = freeParameters(i,j).theta
                        Phi = freeParameters(i,j).phi
                    
                    %Just Added
                        for k = 1:height(trialList(:,1))
                            I = trialList{k,1};
                            M = trialList{k,2};
                            B = trialList{k,3};
                            E = trialList{k,4};
                            Choices = 0:1:(I*M);

                            % Compute Utility

                            freeParameters(i,j).predictions(k) = %toCompute
                        end
                    end
                end

        .. tab-item:: Python

            ::

                for i in range(len(freeParameters)):
                    Theta = freeParameters[i, 0]
                    Phi = freeParameters[i, 1]
                    
                    #Just Added
                    for k in range(len(trialList)):
                        I = trialList[k, 0]
                        M = trialList[k, 1]
                        B = trialList[k, 2]
                        E = trialList[k, 3]
                        Choices = list(range(0, I * M + 1, 1))

                        # Compute Utility
                        
                        predictions[i, k] = # To Compute

.. dropdown:: Define the :bdg-danger:`Decisions` Loop

        .. tab-set::
            
            .. tab-item:: R

                ::

                    non_specific = rep(0, length(freeParameters[,1])) # Just Added This Line
                    
                    for (i in 1:length(freeParameters[,1])){
                        Theta = freeParameters[i,1]
                        Phi = freeParameters[i,2]
                        
                        for (k in 1:length(trialList[,1])){
                            I = trialList[k, 1]
                            M = trialList[k, 2]
                            B = trialList[k, 3]
                            E = trialList[k, 4]
                            Choices = seq(0, (I * M), 1)
                            
                            # Just Added
                            Utility = vector('numeric', length(Choices))
                            for (n in 1:length(Choices)){
                                Utility[n] = utility(theta = Theta,
                                                    phi = Phi,
                                                    guilt = guilt(I, B, Choices[n]),
                                                    inequity = inequity(I, M, Choices[n], E,),
                                                    payout = payout_maximization(I, M, R))
                            }
                            correct_choice = which(Utility == max(Utility))
                            if (length(correct_choice) > 1){
                                correct_choice = correct_choice[sample(correct_choice, 1)]
                                non_specific[i] =+ 1
                            }
                            predictions[i,k] = Choices[correct_choice]
                        }
                    }
                    
            .. tab-item:: MatLab

                ::
                
                    freeParameters = struct('theta', {}, 'phi', {}, 'predictions', {}, non_specific, {});
                    for i = 1:numel(thetaRange)
                        for j = 1:numel(phiRange)
                            Theta = freeParameters(i,j).theta
                            Phi = freeParameters(i,j).phi
                            
                            for k = 1:height(trialList(:,1))
                                I = trialList{k,1};
                                M = trialList{k,2};
                                B = trialList{k,3};
                                E = trialList{k,4};
                                Choices = 0:1:(I*M);

                                Utility = zeros(size(Choices));
                                for n = 1:height(Choices(:,1))
                                    Utility(n) = utility(theta = Theta,
                                                         phi = Phi,
                                                         guilt = guilt(I, B, Choices(n)),
                                                         inequity = inequity(I, M, Choices(n), E,),
                                                         payout = payout_maximization(I, M, R))
                                end
                                correct_choice = find(Utility == max(Utility));
                                if numel(correct_choice) > 1
                                    correct_choice = correct_choice(randi(numel(correct_choice)));
                                    non_specific(i) = non_specific(i) + 1;
                                end
                                freeParameters(i,j).predictions(k) = Choices(correct_choice)
                            end
                        end
                    end

                    
            .. tab-item:: Python

                ::

                    non_specific = [0] * len(freeParameters)

                    for i in range(len(freeParameters)):
                        Theta = freeParameters[i, 0]
                        Phi = freeParameters[i, 1]

                        for k in range(len(trialList)):
                            I = trialList[k, 0]
                            M = trialList[k, 1]
                            B = trialList[k, 2]
                            E = trialList[k, 3]
                            Choices = list(range(0, I * M + 1, 1))

                            Utility = [0] * len(Choices)
                            for n in range(len(Choices)):
                                Utility[n] = utility(theta=Theta,
                                                    phi=Phi,
                                                    guilt=guilt(I, B, Choices[n]),
                                                    inequity=inequity(I, M, Choices[n], E),
                                                    payout=payout_maximization(I, M, R))
                            
                            correct_choice = [idx for idx, val in enumerate(Utility) if val == max(Utility)]
                            if len(correct_choice) > 1:
                                correct_choice = random.sample(correct_choice, 1)
                                non_specific[i] += 1

                            predictions[i, k] = Choices[correct_choice[0]]